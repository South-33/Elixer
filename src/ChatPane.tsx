import React, { useState, useRef, useEffect, Dispatch, SetStateAction } from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../convex/_generated/api";
import { Id } from "../convex/_generated/dataModel";
import ReactMarkdown from 'react-markdown';
import { toast } from "sonner";
import { TrashIcon } from '@heroicons/react/20/solid';

// Type for Convex message document
type MessageDoc = {
  _id: Id<"messages">;
  _creationTime: number;
  role: string;
  content: string;
  userId: Id<"users">;
  systemPrompt?: string;
  isStreaming?: boolean;
  paneId?: string; // Added paneId, now optional
  metadata?: any; // Added metadata field for search suggestions HTML and other data
  processingPhase?: string; // Added processingPhase field to track current AI operation
};

interface ChatPaneProps {
  userId?: Id<"users">; // Make userId optional
  paneId: string;
  lawPrompt: string;
  tonePrompt: string;
  policyPrompt: string;
  onSendMessage: (content: string, model: string, paneId: string, disableSystemPrompt: boolean, disableToolUse: boolean) => Promise<void>;
  onClearChat: () => void; // Callback for clearing chat
  onStreamingStatusChange: (paneId: string, isStreaming: boolean) => void; // New callback
  onMessagesStatusChange: (paneId: string, hasMessages: boolean) => void; // New callback for message presence
  registerSendHandler: (paneId: string, handler: (content: string) => Promise<void>) => void; // New prop
  unregisterSendHandler: (paneId: string) => void; // New prop
  registerResetStatesHandler: (paneId: string, handler: () => void) => void; // New prop
  unregisterResetStatesHandler: (paneId: string) => void; // New prop
}


// We're not using the TypewriterText component anymore - simplified approach

// Custom component to parse and display search suggestions in our own styling
const CustomSearchSuggestions = ({ html, expanded }: { html: string, expanded: boolean }) => {
  // Parse the links from the HTML
  const [links, setLinks] = useState<{ text: string, url: string }[]>([]);

  useEffect(() => {
    if (!html) return;

    try {
      // Create a temporary element to parse the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;

      // Extract all links
      const anchorElements = tempDiv.querySelectorAll('a');
      const extractedLinks = Array.from(anchorElements).map(anchor => ({
        text: anchor.textContent || 'Link',
        url: anchor.getAttribute('href') || '#'
      }));

      setLinks(extractedLinks.slice(0, 5)); // Limit to 5 links for simplicity
    } catch (error) {
      console.error('Error parsing search suggestions HTML:', error);
    }
  }, [html]);

  if (!expanded || links.length === 0) return null;

  return (
    <div className="search-links-container ml-2 flex-shrink-0 flex items-center space-x-2 animate-fadeIn">
      {links.map((link, index) => (
        <a
          key={index}
          href={link.url}
          target="_blank"
          rel="noopener noreferrer"
          className="px-2 py-1 bg-gray-100 text-slate-600 text-xs hover:bg-slate-200 hover:text-slate-900 transition-colors border border-gray-300 whitespace-nowrap overflow-hidden text-ellipsis max-w-[150px] font-mono uppercase tracking-wide"
          style={{ textDecoration: 'none', borderRadius: '2px' }}
        >
          {link.text}
        </a>
      ))}
    </div>
  );
};

// Add CSS styles for the typewriter effect and animations
const customStyles = `
  .typewriter-container {
    display: inline-block;
  }
  .typewriter-text {
    display: inline-block;
    overflow: hidden;
    border-right: 2px solid;
    white-space: nowrap;
    margin: 0;
    letter-spacing: normal;
    animation: typing 2s steps(40, end), blink-caret 0.75s step-end infinite;
  }
  @keyframes typing {
    from { width: 0 }
    to { width: 100% }
  }
  @keyframes blink-caret {
    from, to { border-color: transparent }
    50% { border-color: #888 }
  }
  
  /* Animation for search links fade-in */
  .animate-fadeIn {
    animation: fadeIn 0.3s ease-in-out;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateX(-10px); }
    to { opacity: 1; transform: translateX(0); }
  }

  .streaming-wrapper-display-contents {
    display: contents; /* Allows prose to style children as if they were direct descendants */
  }

  /*
   * --- THE FIX for the "popping" bug ---
   * When a message is streaming, the '.streaming-text-container' class is active on the '.prose' bubble.
   * This rule targets ALL direct children (*) of that bubble.
   * We force their vertical margins and padding to zero to prevent any layout shifts
   * caused by partially rendered Markdown elements (like empty paragraphs).
   * The "!important" flag is needed to override the high-specificity styles from the 'prose' class.
   * The "display: contents" on the inner wrapper makes the elements generated by ReactMarkdown behave as direct children.
  */
  .prose.streaming-text-container > * {
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
  }
`;

// Add the styles to the document (outside of any component)
(function addStylesOnce() {
  if (typeof document !== 'undefined') {
    const styleId = 'elixer-custom-styles';
    if (!document.getElementById(styleId)) {
      const styleElement = document.createElement('style');
      styleElement.id = styleId;
      styleElement.innerHTML = customStyles;
      document.head.appendChild(styleElement);
    }
  }
})();

// Processing phase component to show different AI states with a pulsing animation
const ProcessingPhase = ({ phase }: { phase: string }) => {
  // Icon mapping for different phases
  const getPhaseIcon = (phaseText: string) => {

    if (phaseText.includes("Database") || phaseText.includes("Query")) {
      return "üóÉÔ∏è ";
    } else if (phaseText.includes("Searching") || phaseText.includes("search_web")) {
      return "üîç ";
    } else if (phaseText.includes("Thinking") || phaseText.includes("Analyzing")) {
      return "üí≠ ";
    } else if (phaseText.includes("Generating") || phaseText.includes("Writing")) {
      return "‚úèÔ∏è ";
    } else if (phaseText.includes("Ranking") || phaseText.includes("Prioritizing")) {
      return "üî¢ ";
    }
    return "";
  };

  return (
    <span className="processing-phase-content">
      {getPhaseIcon(phase)}{phase}
    </span>
  );
};

// Chat message component with DOM-based streaming for assistant messages
const ChatMessage = ({ message, currentPhaseToShow }: { message: MessageDoc, currentPhaseToShow?: string }) => {
  const [suggestionsExpanded, setSuggestionsExpanded] = useState(false);
  const phaseToDisplay = currentPhaseToShow || message.processingPhase;

  return (
    <div
      className={`flex flex-col ${message.role === "user" ? "items-end" : "items-start"}`}
    >
      <div
        className={`max-w-[85%] sm:max-w-[80%] p-4 shadow-sm border ${message.role === "user"
          ? "bg-slate-800 text-white border-slate-900"
          : `bg-white text-slate-900 border-gray-300 prose ${message.isStreaming ? "streaming-text-container" : ""}`.trim()
          }`}
        style={{ borderRadius: '2px' }}
      >
        {message.role === "assistant" && message.isStreaming && message.content === "" && phaseToDisplay ? (
          <div className="processing-phase">
            <ProcessingPhase phase={phaseToDisplay} />
          </div>
        ) : message.role === "assistant" && message.isStreaming && message.content ? (
          <ReactMarkdown>{message.content}</ReactMarkdown>
        ) : (
          <ReactMarkdown>{message.content}</ReactMarkdown>
        )}
      </div>

      {/* Render horizontally expanding search suggestions if available */}
      {message.role === "assistant" && message.metadata && (message.metadata as any).searchSuggestionsHtml && (
        <div className="mt-2 flex items-center">
          <button
            onClick={() => setSuggestionsExpanded(!suggestionsExpanded)}
            className="text-xs font-mono uppercase tracking-wider px-3 py-1 bg-gray-100 border border-gray-300 text-slate-600 hover:bg-gray-200 transition-colors focus:outline-none flex items-center justify-center flex-shrink-0"
            style={{ width: '140px', borderRadius: '2px' }}
          >
            <span className="mr-1">{suggestionsExpanded ? 'HIDE SOURCES' : 'VIEW SOURCES'}</span>
            <svg
              className={`w-3 h-3 transition-transform ${suggestionsExpanded ? 'transform rotate-90' : ''}`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>

          <CustomSearchSuggestions
            html={(message.metadata as any).searchSuggestionsHtml}
            expanded={suggestionsExpanded}
          />
        </div>
      )}
    </div>
  );
};


export function ChatPane({ userId, paneId, lawPrompt, tonePrompt, policyPrompt, onSendMessage, onClearChat, onStreamingStatusChange, onMessagesStatusChange, registerSendHandler, unregisterSendHandler, registerResetStatesHandler, unregisterResetStatesHandler }: ChatPaneProps) {
  const messages = useQuery(
    api.chat.getMessages,
    userId ? { userId, paneId } : "skip"
  ) || [] as MessageDoc[];

  const [selectedModel, setSelectedModel] = useState("gemini-2.5-flash"); // Default model for this pane
  const [disableSystemPrompt, setDisableSystemPrompt] = useState(false); // New state for disabling system prompt - off by default
  const [disableToolUse, setDisableToolUse] = useState(false); // New state for disabling tool use - off by default

  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Current processing phase for the assistant
  const [currentProcessingPhase, setCurrentProcessingPhase] = useState<string>("Thinking");
  const [showLocalPendingIndicator, setShowLocalPendingIndicator] = useState<boolean>(false);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // Function to reset local streaming states
  const resetLocalStreamingStates = () => {
    setCurrentProcessingPhase("Thinking");
    setShowLocalPendingIndicator(false);
  };

  // Report message status to parent
  useEffect(() => {
    onMessagesStatusChange(paneId, messages.length > 0);
  }, [messages.length, paneId, onMessagesStatusChange]);

  useEffect(() => {
    console.log("[ChatPane] useEffect triggered. Messages updated."); // Log when messages update
    const streamingDbMessage = messages.find((msg: MessageDoc) => msg.role === "assistant" && msg.isStreaming);

    // Update processing phase if available from the backend
    if (streamingDbMessage) {
      setShowLocalPendingIndicator(false); // DB message exists, hide local indicator
      if (streamingDbMessage.processingPhase) {
        console.log(`[ChatPane] Setting processing phase from backend: ${streamingDbMessage.processingPhase}`);
        setCurrentProcessingPhase(streamingDbMessage.processingPhase);
      }
    } else {
      // No DB streaming message, but local indicator might be on if we just sent a message
      // If showLocalPendingIndicator is true, it means we are awaiting the initial message creation by backend.
      // If it's false, it means either not streaming or backend message hasn't been created yet after a send.
    }

    return () => {
      if (streamingDbMessage) {
        console.log("[ChatPane] Streaming finished or message no longer streaming.");
      }
    };
  }, [messages]);


  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // This is the global "isStreaming" used to disable UI elements
  const isStreaming = messages.some((msg: MessageDoc) => msg.isStreaming) || showLocalPendingIndicator;

  useEffect(() => {
    onStreamingStatusChange(paneId, isStreaming);
  }, [isStreaming, paneId, onStreamingStatusChange]);

  // This handleSend is now internal to ChatPane, called by AuthenticatedContent's global handleSend
  const handleInternalSend = async (content: string) => {
    const userMessageContent = content.trim();
    const isCurrentlyStreaming = messages.some((msg: MessageDoc) => msg.isStreaming) || showLocalPendingIndicator;

    if (!userMessageContent || isCurrentlyStreaming) return;

    // Add detailed logging for each pane when sending a message
    console.log(`[ChatPane ${paneId}] Sending message with settings:`, {
      disableSystemPrompt,
      disableToolUse,
      selectedModel,
      contentPreview: userMessageContent.substring(0, 50) + (userMessageContent.length > 50 ? '...' : ''),
      timestamp: new Date().toISOString()
    });

    // Reset the current phase to thinking and ensure it's visible
    setCurrentProcessingPhase("Thinking");
    setShowLocalPendingIndicator(true); // Show local pending state immediately

    try {
      if (!userId) {
        console.error("User not loaded, cannot send message.");
        toast.error("User not loaded. Please wait a moment.");
        setShowLocalPendingIndicator(false);
        return;
      }
      await onSendMessage(userMessageContent, selectedModel, paneId, disableSystemPrompt, disableToolUse);
    } catch (error: any) { // Explicitly type error as any to access properties
      console.error("Failed to send message:", error);
      setShowLocalPendingIndicator(false); // Hide pending indicator on send error

      if (error.data && error.data.code === "TOO_MANY_REQUESTS") {
        toast.error("You've exceeded your API quota. Please try again later.");
      } else {
        toast.error("Failed to send message. Please try again.");
      }
    }
  };

  // Register and unregister the internal send handler
  useEffect(() => {
    registerSendHandler(paneId, handleInternalSend);
    registerResetStatesHandler(paneId, resetLocalStreamingStates); // Register the reset handler
    return () => {
      unregisterSendHandler(paneId);
      unregisterResetStatesHandler(paneId); // Unregister the reset handler
    };
  }, [paneId, registerSendHandler, unregisterSendHandler, registerResetStatesHandler, unregisterResetStatesHandler]);

  return (
    <div className="flex-1 flex flex-col bg-white border-r border-gray-300 last:border-r-0 h-full">
      <div className="p-3 border-b border-gray-300 bg-[#F9F9F7] flex items-center justify-between">
        <h3 className="text-sm font-semibold text-slate-700 uppercase tracking-wide flex items-center gap-2">
          <span className="w-2 h-2 bg-teal-600 rounded-full inline-block"></span>
          Chat {paneId.replace('pane-', '#')}
        </h3>
        <div className="flex items-center gap-2">
          <button
            onClick={() => setDisableSystemPrompt(prev => !prev)}
            className={`px-3 py-1.5 text-xs font-mono font-medium border transition-colors ${disableSystemPrompt
              ? "bg-white border-gray-300 text-gray-500 hover:text-red-600"
              : "bg-slate-800 border-slate-800 text-white"
              }`}
            style={{ borderRadius: '2px' }}
            disabled={isStreaming}
          >
            {disableSystemPrompt ? "System [Off]" : "System [On]"}
          </button>
          <button
            onClick={() => setDisableToolUse(prev => !prev)}
            className={`px-3 py-1.5 text-xs font-mono font-medium border transition-colors ${disableToolUse
              ? "bg-white border-gray-300 text-gray-500 hover:text-red-600"
              : "bg-slate-700 border-slate-700 text-white"
              }`}
            style={{ borderRadius: '2px' }}
            disabled={isStreaming}
          >
            {disableToolUse ? "AGENT [OFF]" : "AGENT [ON]"}
          </button>
          <select
            value={selectedModel}
            onChange={(e) => setSelectedModel(e.target.value)}
            className="p-1.5 border border-gray-300 bg-white text-xs font-mono focus:ring-1 focus:ring-slate-500 outline-none"
            style={{ borderRadius: '2px' }}
            disabled={isStreaming}
          >
            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
            <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash Lite</option>
            <option value="gemini-2.5-flash">Gemini 2.0 Flash</option>
          </select>
          <button
            onClick={onClearChat}
            className="p-2 bg-white border border-gray-300 text-slate-600 hover:text-red-600 hover:border-red-300 transition-colors shadow-sm"
            style={{ borderRadius: '2px' }}
            title="Clear Chat History"
          >
            <TrashIcon className="h-4 w-4" />
            <span className="sr-only">Clear Chat History</span>
          </button>
        </div>
      </div>
      <div className="flex-1 overflow-y-auto p-4 sm:p-6 space-y-4 custom-scrollbar">
        {messages.map((message: MessageDoc) => (
          <ChatMessage
            key={`${message._id}-${message.isStreaming ? 'streaming' : 'static'}-${message.content.length}`}
            message={message}
            currentPhaseToShow={message.role === 'assistant' && message.isStreaming && !message.content ? message.processingPhase : undefined}
          />
        ))}
        {showLocalPendingIndicator &&
          !messages.some((msg: MessageDoc) => msg.role === 'assistant' && msg.isStreaming) && (
            <div className="flex justify-start" key="local-pending-jsx-indicator">
              <div className="max-w-[80%] p-4 bg-white border border-gray-300 text-slate-800" style={{ borderRadius: '2px' }}>
                <div className="processing-phase">
                  <ProcessingPhase phase={currentProcessingPhase} />
                </div>
              </div>
            </div>
          )}
        <div ref={messagesEndRef} />
      </div>
    </div>
  );
}